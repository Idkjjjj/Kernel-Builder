##!/bin/bash
# Bash Color
green='\e[32m'
red='\e[31m'
yellow='\e[33m'
blue='\e[34m'
lgreen='\e[92m'
lyellow='\e[93m'
lblue='\e[94m'
lmagenta='\e[95m'
lcyan='\e[96m'
blink_red='\033[05;31m'
restore='\033[0m'
reset='\e[0m'

# NetHunter Stage 1 Kernel Build Script
# Heavily Modified to fit with a cron single cron
# job a Ubuntu
#
# This script if heavily based on work by holyangle
# https://gitlab.com/HolyAngel/op7
##############################################


# Build directory
BUILD_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

##############################################
# Functions
##############################################
# Pause
function pause() {
	local message="$@"
	[ -z $message ] && message="Press [Enter] to continue.."
	read -p "$message" readEnterkey
}

function ask() {
    # http://djm.me/ask
    while true; do

        if [ "${2:-}" = "Y" ]; then
            prompt="Y/n"
            default=Y
        elif [ "${2:-}" = "N" ]; then
            prompt="y/N"
                default=N
        else
                prompt="y/n"
                default=
        fi

        # Ask the question
        question
        read -p "$1 [$prompt] " REPLY

        # Default?
        if [ -z "$REPLY" ]; then
            REPLY=$default
        fi

        # Check if the reply is valid
        case "$REPLY" in
            Y*|y*) return 0 ;;
            N*|n*) return 1 ;;
        esac
    done
}

function info() {
    printf "${lcyan}[   INFO   ]${reset} $*${reset}\n"
}

function success() {
    printf "${lgreen}[ SUCCESS  ]${reset} $*${reset}\n"
}

function warning() {
    printf "${lyellow}[ WARNING  ]${reset} $*${reset}\n"
}

function error() {
    printf "${lmagenta}[  ERROR   ]${reset} $*${reset}\n"
}

function question() {
    printf "${yellow}[ QUESTION ]${reset} "
}

# Install dependencies
function get_dependencies() {
    info "Installing dependencies"
    sudo apt-get update
	for i in $DEBIAN_DEPEND; do
        sudo apt-get install -y $i
    done
}

# Download toolchain; required arguments: "source URL" "Download type(wget/git)"
function get_toolchain() {
	local url=$1
	local type=$2
    local TMP_DIR="${BUILD_DIR}/toolchain_archs"
	if [ ${type} == "wget" ]; then
	    wget_file ${url} ${TMP_DIR}
		return $?
	else
	    error "Download type ${type} not availabe"
	fi
}

# Download all toolchains
function get_toolchains() {
    local ARCH_DIR="${BUILD_DIR}/toolchain_archs"
	mkdir -p ${ARCH_DIR}
	## clang
    if [ ! -z "${CLANG_SRC}" ]; then
		printf "\n"
		info "Downloading clang toolchain"
		if [ -z "${CLANG_SRC_TYPE}" ]; then
            CLANG_SRC_TYPE="wget"
		fi
	    get_toolchain ${CLANG_SRC} ${CLANG_SRC_TYPE}
	    if [ $? -eq 0 ]; then
			if [ ! -d ${CLANG_ROOT} ]; then
                local archive="${CLANG_SRC##*/}"
			    mkdir -p ${CLANG_ROOT}
		        tar -xJf ${ARCH_DIR}/${archive} -C ${CLANG_ROOT} --strip-components=1
			else
				warning "Skipping ${archive}"
			fi
		    info "Done"
		fi
	fi
	## gcc32
    if [ ! -z "${CROSS_COMPILE_ARM32_SRC}" ]; then
		printf "\n"
		info "Downloading 32bit gcc toolchain"
		if [ -z "${CROSS_COMPILE_ARM32_TYPE}" ]; then
            CROSS_COMPILE_ARM32_TYPE="wget"
		fi
	    get_toolchain ${CROSS_COMPILE_ARM32_SRC} ${CROSS_COMPILE_ARM32_TYPE}
	    if [ $? -eq 0 ]; then
			if [ ! -d ${CCD32} ]; then
                local archive="${CROSS_COMPILE_ARM32_SRC##*/}"
			    mkdir -p ${CCD32}
		        tar -xJf ${ARCH_DIR}/${archive} -C ${CCD32} --strip-components=1
			else
				warning "Skipping ${archive}"
			fi
		    info "Done"
		fi
	fi
	## gcc64
    if [ ! -z "${CROSS_COMPILE_SRC}" ]; then
		printf "\n"
		info "Downloading 64bit gcc toolchain"
		if [ -z "${CROSS_COMPILE_SRC_TYPE}" ]; then
            CROSS_COMPILE_SRC_TYPE="wget"
		fi
	    get_toolchain ${CROSS_COMPILE_SRC} ${CROSS_COMPILE_SRC_TYPE}
	    if [ $? -eq 0 ]; then
			if [ ! -d ${CCD64} ]; then
                local archive="${CROSS_COMPILE_SRC##*/}"
			        mkdir -p ${CCD64}
		            tar -xJf ${ARCH_DIR}/${archive} -C ${CCD64} --strip-components=1
			else
				warning "Skipping ${archive}"
			fi
		    info "Done"
		fi
	fi
}

# Setup environment
function setup_env() {
	setup_dirs
	get_dependencies
	get_toolchains
}

# Clean "out" folders
function make_oclean() {
	printf "\n"
	info "Cleaning up kernel-out & modules-out directories"
	## Let's make sure we dont't delete the kernel source if we compile in the source tree
	if [ "$KDIR" == "$KERNEL_OUT" ]; then
		# Clean the source tree as well if we use it to build the kernel, i.e. we have no OUT directory
		make -C $KDIR clean && make -C $KDIR mrproper
		rm -f $KDIR/source
	else
		rm -rf "$KERNEL_OUT"
	fi
	rm -rf "$MODULES_OUT"
	success "Out directories removed!"
}

# Clean source tree
function make_sclean() {
	local confdir=${KDIR}/arch/$ARCH/configs
	printf "\n"
	info "Cleaning source directory"
	if [ -f ${confdir}/$CONFIG.old ]; then
	    rm -f ${confdir}/$CONFIG.old
	fi
	if [ -f ${confdir}/$CONFIG.new ]; then
	    rm -f ${confdir}/$CONFIG.new
	fi
	success "Source directory cleaned"
}

# Create kernel compilation working directories
function setup_dirs() {
	info "Creating new out directory"
	mkdir -p "$KERNEL_OUT"
	success "Created new out directory"
	info "Creating new modules_out directory"
	mkdir -p "$MODULES_OUT"
	success "Created new modules_out directory"
}

# Edit .config in working directory
function edit_config() {
	local cc
	printf "\n"
    # CC=clang cannot be exported. Let's compile with clang if "CC" is set to "clang" in the config
	if [ "$CC" == "clang" ]; then
		cc="CC=clang"
	fi
    get_defconfig || return 1

	info "Create config"
	make -C $KDIR O="$KERNEL_OUT" $cc $CONFIG
	fi
	cfg_done=true
}

# copy version file across
function copy_version() {
	if [ ! -z ${SRC_VERSION} ] && [ ! -z ${TARGET_VERSION} ] && [ -f ${SRC_VERSION} ]; then
		cp -f ${SRC_VERSION} ${TARGET_VERSION}
	fi
	return 0
}

# Compile the kernel
function make_kernel() {
	local cc
	local confdir=${KDIR}/arch/$ARCH/configs
	printf "\n"
        # CC=clang cannot be exported. Let's compile with clang if "CC" is set to "clang" in the config
	if [ "$CC" == "clang" ]; then
		cc="CC=clang"
	fi
	enable_ccache
	echo ${CC}
	echo ${CROSS_COMPILE}
	echo ${CROSS_COMPILE_ARM32}
	info "~~~~~~~~~~~~~~~~~~"
	info " Building kernel"
	info "~~~~~~~~~~~~~~~~~~"
	copy_version
	grep "CONFIG_MODULES=y" ${KERNEL_OUT}/.config >/dev/null && MODULES=true
	## Some kernel sources do not compile into a separate $OUT directory so we set $OUT = $ KDIR
	## This works with clean and config targets but not for a build, we'll catch this here
	if [ "$KDIR" == "$KERNEL_OUT" ]; then
		if [ "$CC" == "ccache clang" ]; then
			time make -C $KDIR CC="ccache clang"  -j "$THREADS" ${MAKE_ARGS}
			if [ "$MODULES" = true ]; then
		    	time make -C $KDIR CC="ccache clang" -j "$THREADS" INSTALL_MOD_PATH=$MODULES_OUT modules_install
			fi
		else
			time make -C $KDIR $cc -j "$THREADS" ${MAKE_ARGS}
			if [ "$MODULES" = true ]; then
		    	time make -C $KDIR $cc -j "$THREADS" INSTALL_MOD_PATH=$MODULES_OUT modules_install
			fi
		fi
	else
		if [ "$CC" == "ccache clang" ]; then
			time make -C $KDIR O="$KERNEL_OUT" CC="ccache clang" -j "$THREADS" ${MAKE_ARGS}
			if [ "$MODULES" = true ]; then
		    	time make -C $KDIR O="$KERNEL_OUT" CC="ccache clang" -j "$THREADS" INSTALL_MOD_PATH=$MODULES_OUT modules_install
			fi
		else
			time make -C $KDIR O="$KERNEL_OUT" $cc -j "$THREADS" ${MAKE_ARGS}
			if [ "$MODULES" = true ]; then
		    	time make -C $KDIR O="$KERNEL_OUT" $cc -j "$THREADS" INSTALL_MOD_PATH=$MODULES_OUT modules_install
			fi
		fi
	fi
	rm -f ${MODULES_OUT}/lib/modules/*/source
	rm -f ${MODULES_OUT}/lib/modules/*/build
	success "Kernel build completed"
}

# Clean anykernel directory
function make_aclean() {
	printf "\n"
	info "Cleaning up anykernel zip directory"
	rm -rf $ANYKERNEL_DIR/Image* $ANYKERNEL_DIR/dtb $CHANGELOG ${ANYKERNEL_DIR}/modules
	success "Anykernel directory cleaned"
}

# Generate the anykernel zip
function make_anykernel_zip() {
	printf "\n"
	mkdir -p ${UPLOAD_DIR}
	info "Copying kernel to anykernel zip directory"
	cp "$KERNEL_IMAGE" "$ANYKERNEL_DIR"
	if [ "$DO_DTBO" = true ]; then
		info "Copying dtbo to zip directory"
		cp "$DTBO_IMAGE" "$ANYKERNEL_DIR"
	fi
	if [ "$DO_DTB" = true ]; then
		info "Generating dtb in zip directory"
		make_dtb ${ANYKERNEL_DIR}
	fi
	if [ -d ${MODULES_OUT}/lib ]; then
		info "Copying modules to zip directory"
		mkdir -p ${ANYKERNEL_DIR}/${MODULE_DIRTREE}
		cp -r ${MODULES_IN} ${ANYKERNEL_DIR}/${MODULE_DIRTREE}
	fi
	success "Done"
	make_clog
	printf "\n"
	info "Creating anykernel zip file"
	cd "$ANYKERNEL_DIR"
	zip -r "$ANY_ARCHIVE" *
	info "Moving anykernel zip to output directory"
	mv "$ANY_ARCHIVE" "$UPLOAD_DIR"
	printf "\n"
	success "Anykernel zip:\n${lcyan}$ANY_ARCHIVE\n${reset}is now available in:\n${lcyan}${UPLOAD_DIR}"
	cd $BUILD_DIR
	printf "\n"
}

function compile_kernel() {
    make_oclean
    make_sclean
    setup_dirs
    edit_config && make_kernel
}

# from DJY anykernel file (perfect for OnePlus6T)
function voodoo_anykernelDJY() {
    make_aclean
    make_anykernel_zip
}

# Main
clear
####################################################################
# Load configuration:                                             #
source ${BUILD_DIR}/config

if [[ ! -f "${BUILD_DIR}/.setup_complete" ]]; then
    setup_env
fi

compile_kernel

voodoo_any
